!pip install playwright nest_asyncio bs4 pandas

!playwright install chromium



import asyncio
import nest_asyncio
from playwright.async_api import async_playwright
from bs4 import BeautifulSoup
import pandas as pd
import re

nest_asyncio.apply()

async def find_search_selector(page):
    """
    Пытаемся найти строку поиска по набору возможных селекторов.
    Возвращаем первый сработавший селектор.
    """
    selectors = [
        'input[id="searchInput"]',
        'input[id*="search"]',
        'input[name="search"]',
        'input[type="search"]',
        'input[placeholder*="Поиск"]',
        'input[placeholder*="поиск"]',
        'input[placeholder*="Найти"]',
        'input[placeholder*="найти"]',
        'input[class*="search"]',
    ]

    for sel in selectors:
        loc = page.locator(sel)
        try:
            count = await loc.count()
        except Exception:
            count = 0
        if count > 0:
            print(f"Нашли поле поиска по селектору: {sel}")
            # ждём, пока оно станет видимым/редактируемым
            try:
                await loc.first.wait_for(state="visible", timeout=10000)
            except Exception:
                pass
            return sel

    # если ничего не нашли — печатаем первые символы HTML и падаем с понятной ошибкой
    html = await page.content()
    print("❌ Не нашёл поле поиска. Вот начало HTML страницы:")
    print(html[:2000])
    raise RuntimeError("Не удалось найти строку поиска — страница, возможно, отличается или доступ ограничен.")


async def parse_wildberries_elki():
    all_products = []
    seen_ids = set()
    base_url = "https://www.wildberries.ru"

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        context = await browser.new_context(
            user_agent=(
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
                "AppleWebKit/537.36 (KHTML, like Gecko) "
                "Chrome/120.0.0.0 Safari/537.36"
            ),
            viewport={"width": 1366, "height": 768}
        )
        page = await context.new_page()
        page.set_default_timeout(60000)  # побольше таймауты

        # ------------------------------
        # 1. Открываем Wildberries
        # ------------------------------
        await page.goto(base_url)
        await page.wait_for_load_state("networkidle")
        print("Открыли страницу:", page.url)
        print("Title:", await page.title())

        # пробуем закрыть всплывашки (если есть)
        try:
            await page.click("button[aria-label*='Закрыть'], button[aria-label*='закрыть']")
        except:
            pass

        # ------------------------------
        # 2. Находим строку поиска и вводим "ёлка"
        # ------------------------------
        search_selector = await find_search_selector(page)

        query = "ёлка"
        await page.fill(search_selector, query)
        await page.press(search_selector, "Enter")
        await page.wait_for_load_state("networkidle")

        # ------------------------------
        # 3. Обход первых 5 страниц
        # ------------------------------
        for page_num in range(1, 6):
            print(f"\nСобираю данные со страницы {page_num}...")

            if page_num > 1:
                url = (
                    "https://www.wildberries.ru/catalog/0/search.aspx"
                    "?search=%D0%B5%D0%BB%D0%BA%D0%B0&page=" + str(page_num)
                )
                await page.goto(url)
                await page.wait_for_load_state("networkidle")
                print("URL страницы:", page.url)

            html = await page.content()
            soup = BeautifulSoup(html, "html.parser")

            cards = soup.select("article[data-nm-id]")
            if not cards:
                cards = soup.select("div.product-card")

            print("  Найдено карточек:", len(cards))

            for card in cards:
                nm_id = card.get("data-nm-id")
                if nm_id:
                    if nm_id in seen_ids:
                        continue
                    seen_ids.add(nm_id)

                # Название
                name_elem = (
                    card.select_one("[class*='product-card__name']")
                    or card.select_one("a.product-card__name")
                    or card.select_one("span.product-card__name")
                )
                if name_elem:
                    name = name_elem.get_text(strip=True)
                else:
                    img = card.find("img")
                    name = img.get("alt", "").strip() if img else ""

                if not name:
                    continue

                # Цена
                price_elem = (
                    card.select_one("ins[class*='lower-price']")
                    or card.select_one("span[class*='lower-price']")
                    or card.select_one("p[class*='price']")
                )
                if price_elem:
                    price_text = price_elem.get_text(" ", strip=True)
                else:
                    price_text = ""

                digits = re.findall(r"\d+", price_text.replace("\xa0", " "))
                price_value = int("".join(digits)) if digits else None

                # Ссылка
                link_elem = card.find("a", href=True)
                if link_elem:
                    href = link_elem["href"]
                    if href.startswith("/"):
                        href = base_url + href
                else:
                    href = ""

                all_products.append(
                    {
                        "Название": name,
                        "Цена": price_value,
                        "Ссылка": href,
                    }
                )

        await browser.close()

    # ------------------------------
    # 4. pandas + CSV + min/max
    # ------------------------------
    df = pd.DataFrame(all_products)
    df = df.dropna(subset=["Цена"])
    df = df.drop_duplicates(subset=["Ссылка"])
    df["Цена"] = df["Цена"].astype(int)

    print("\nВсего ёлок в таблице:", len(df))

    csv_name = "wildberries_elki.csv"
    df.to_csv(csv_name, index=False, encoding="utf-8-sig")
    print(f"Таблица сохранена в файл {csv_name}")

    cheapest = df.loc[df["Цена"].idx_min()]
    most_expensive = df.loc[df["Цена"].idx_max()]

    print("\nСамая дешёвая ёлка:")
    print(cheapest)

    print("\nСамая дорогая ёлка:")
    print(most_expensive)

    return df, cheapest, most_expensive

df, cheapest, most_expensive = asyncio.run(parse_wildberries_elki())