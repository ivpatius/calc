import asyncio, nest_asyncio, pandas as pd
from urllib.parse import urlencode
from playwright.async_api import async_playwright

nest_asyncio.apply()

SEARCH_ENDPOINT = "https://search.wb.ru/exactmatch/ru/common/v4/search"
DEST = "-1257786"  # часто используют для РФ; если нужно — можно поменять

def build_url(query: str, page: int) -> str:
    params = {
        "appType": "1",
        "curr": "rub",
        "dest": DEST,
        "query": query,
        "page": str(page),
        "resultset": "catalog",
        "sort": "popular",
        "spp": "0",
    }
    return f"{SEARCH_ENDPOINT}?{urlencode(params)}"

def product_link(nm_id: int) -> str:
    return f"https://www.wildberries.ru/catalog/{nm_id}/detail.aspx"

async def run(query="ёлка", pages=5):
    rows = []
    seen = set()

    async with async_playwright() as p:
        # request-контекст Playwright (без открытия сайта в браузере)
        req = await p.request.new_context(
            extra_http_headers={
                "Accept": "application/json, text/plain, */*",
                "Accept-Language": "ru-RU,ru;q=0.9",
                "User-Agent": (
                    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
                    "AppleWebKit/537.36 (KHTML, like Gecko) "
                    "Chrome/120.0.0.0 Safari/537.36"
                ),
                "Origin": "https://www.wildberries.ru",
                "Referer": "https://www.wildberries.ru/",
            }
        )

        for page in range(1, pages + 1):
            url = build_url(query, page)
            print("GET:", url)

            resp = await req.get(url, timeout=60000)
            if not resp.ok:
                text = await resp.text()
                raise RuntimeError(f"HTTP {resp.status} на странице {page}. Ответ: {text[:500]}")

            data = await resp.json()

            products = (data.get("data") or {}).get("products") or []
            print("  товаров:", len(products))

            for pr in products:
                nm_id = pr.get("id")
                if not nm_id or nm_id in seen:
                    continue
                seen.add(nm_id)

                name = pr.get("name") or ""
                brand = pr.get("brand") or ""

                # цены у WB часто в "копейках * 100" (то есть рубли = значение / 100)
                price_u = pr.get("salePriceU") or pr.get("priceU")
                price = (price_u / 100) if isinstance(price_u, (int, float)) else None

                rows.append({
                    "id": nm_id,
                    "Название": name,
                    "Бренд": brand,
                    "Цена": price,
                    "Ссылка": product_link(nm_id),
                })

        await req.dispose()

    df = pd.DataFrame(rows)
    df = df.dropna(subset=["Цена"]).drop_duplicates(subset=["id"])
    df["Цена"] = df["Цена"].astype(float)

    csv_name = "wildberries_elki.csv"
    df.to_csv(csv_name, index=False, encoding="utf-8-sig")

    cheapest = df.loc[df["Цена"].idxmin()]
    most_expensive = df.loc[df["Цена"].idxmax()]

    print("\n✅ Сохранено:", csv_name)
    print("✅ Всего товаров:", len(df))

    print("\nСамая дешёвая ёлка:")
    print(cheapest)

    print("\nСамая дорогая ёлка:")
    print(most_expensive)

    return df, cheapest, most_expensive

df, cheapest, most_expensive = asyncio.run(run(query="ёлка", pages=5))
df.head(10)


!pip install playwright nest_asyncio pandas
!playwright install chromium
